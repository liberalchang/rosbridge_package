# ROSBridge客户端动态消息发布功能说明

## 问题描述

原始的`start_auto_publish`方法存在一个问题：消息内容在启动自动发布时就被固定了，无法在运行时动态变更话题消息内容。这导致发布的消息始终保持相同的内容，无法满足需要动态更新消息的应用场景。

## 解决方案

我们对`lbrosclient/ros_client.py`中的`ROSBridgeClient`类进行了增强，提供了三种方式来实现动态消息内容：

### 1. 消息生成器（Message Generator）

通过传递一个消息生成器函数，每次发布时都会调用该函数生成新的消息内容。

```python
# 示例：发布当前时间戳
def timestamp_generator():
    return {'data': f'当前时间: {time.strftime("%Y-%m-%d %H:%M:%S")}'}

client.start_auto_publish_with_generator('/time_topic', timestamp_generator, 1.0)
```

### 2. 动态配置更新

通过修改`publish_topics`配置来动态更新消息内容，系统会自动检测配置变化。

```python
# 添加话题配置
client.add_publish_topic(
    topic_key='dynamic_topic',
    topic_name='/test_topic',
    topic_type='std_msgs/String',
    content='初始消息',
    frequency=1
)

# 启动自动发布
client.start_auto_publish('/test_topic')

# 运行时更新消息内容
client.update_publish_content('dynamic_topic', '新的消息内容')
# 或者根据话题名称更新
client.update_publish_content_by_name('/test_topic', '另一个新消息')
```

### 3. 混合模式

可以同时使用消息生成器和动态配置，系统会优先使用消息生成器。

## 新增的API方法

### `start_auto_publish`（增强版）

```python
def start_auto_publish(self, topic_name: str, message_data: Dict[str, Any] = None, 
                      frequency: float = 1.0, message_generator: Callable = None) -> bool:
```

**参数说明：**
- `topic_name`: 话题名称
- `message_data`: 静态消息数据（可选）
- `frequency`: 发布频率（Hz）
- `message_generator`: 消息生成器函数（可选）

### `start_auto_publish_with_generator`

```python
def start_auto_publish_with_generator(self, topic_name: str, message_generator: Callable, 
                                    frequency: float = 1.0) -> bool:
```

专门用于消息生成器的便捷方法。

### `update_publish_content`

```python
def update_publish_content(self, topic_key: str, new_content: Any) -> bool:
```

根据话题配置键名更新消息内容。

### `update_publish_content_by_name`

```python
def update_publish_content_by_name(self, topic_name: str, new_content: Any) -> bool:
```

根据话题名称更新消息内容。

### `get_publish_content`

```python
def get_publish_content(self, topic_key: str) -> Any:
```

获取当前的消息内容。

## 使用示例

### 示例1：基本动态更新

```python
from lbrosclient import ROSBridgeClient, Logger, LogLevel
import time

client = ROSBridgeClient()
client.set_host_port('localhost', 9090)
client.connect()

# 添加话题配置
client.add_publish_topic(
    topic_key='test_topic',
    topic_name='/dynamic_test',
    topic_type='std_msgs/String',
    content='初始消息',
    frequency=1
)

# 创建发布者并启动自动发布
client.create_publisher('/dynamic_test', 'std_msgs/String')
client.start_auto_publish('/dynamic_test')

# 5秒后更新消息内容
time.sleep(5)
client.update_publish_content('test_topic', '更新后的消息')
```

### 示例2：使用消息生成器

```python
# 计数器生成器
counter = {'value': 0}
def counter_generator():
    counter['value'] += 1
    return {'data': f'计数: {counter["value"]}'}

# 启动自动发布
client.create_publisher('/counter', 'std_msgs/String')
client.start_auto_publish_with_generator('/counter', counter_generator, 2.0)
```

### 示例3：复杂消息类型

```python
import math

def twist_generator():
    t = time.time()
    return {
        'linear': {
            'x': 0.5 * math.sin(t * 0.5),
            'y': 0.0,
            'z': 0.0
        },
        'angular': {
            'x': 0.0,
            'y': 0.0,
            'z': 0.3 * math.cos(t * 0.5)
        }
    }

client.create_publisher('/cmd_vel', 'geometry_msgs/Twist')
client.start_auto_publish_with_generator('/cmd_vel', twist_generator, 10.0)
```

## 运行示例

我们提供了两个示例文件：

1. **`roslibpyclient.py`**：更新后的原始示例，展示了基本的动态消息功能
2. **`dynamic_publish_example.py`**：完整的动态消息功能演示

运行示例：

```bash
# 运行基本示例
python roslibpyclient.py

# 运行完整动态功能演示
python dynamic_publish_example.py
```

## 技术实现细节

### 核心改进

1. **消息生成器支持**：在`publish_loop`中每次发布前调用生成器函数
2. **动态配置检测**：通过`_get_dynamic_message_data`方法检查配置变化
3. **类型智能处理**：根据消息类型自动构造合适的消息格式
4. **线程安全**：所有操作都是线程安全的

### 优先级

1. 消息生成器（最高优先级）
2. 动态配置内容
3. 默认消息数据

### 错误处理

- 消息生成器执行失败时会记录错误日志但不会停止发布
- 配置不存在时会使用默认消息
- 所有API都有完整的错误处理和日志记录

## 兼容性

- 完全向后兼容原有的API
- 原有的`start_auto_publish(topic_name, message_data, frequency)`调用方式仍然有效
- 新功能是可选的，不影响现有代码

## 性能考虑

- 消息生成器在每次发布时调用，应避免耗时操作
- 动态配置检查的开销很小
- 建议消息生成器函数保持简单和高效